#!/usr/bin/env python3

import argparse
import subprocess
import json
from datetime import datetime
import sys


# Function to check if the current directory is a Git repository
def is_git_repo():
    try:
        subprocess.run(
            ["git", "rev-parse", "--is-inside-work-tree"],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL,
            check=True,
        )
        return True
    except subprocess.CalledProcessError:
        return False


# Check if inside a Git repository
if not is_git_repo():
    print("Error: This script must be run inside a Git repository.")
    sys.exit(1)

# Set up argument parser
parser = argparse.ArgumentParser(
    description="Display the latest Azure DevOps pipeline runs."
)
parser.add_argument(
    "-n", "--num", type=int, default=1, help="Number of latest runs to display"
)
parser.add_argument(
    "-f",
    "--full-message",
    action="store_true",
    help="Show the full message without truncating",
)
parser.add_argument(
    "-s",
    "--status",
    type=str,
    choices=["inProgress", "completed", "failed", "partiallySucceeded", "cancelling"],
    default="completed",
    help="Filter pipeline runs by status",
)
args = parser.parse_args()

# Run the command and get JSON output
cmd = [
    "az",
    "pipelines",
    "runs",
    "list",
    "--top",
    str(args.num),
    "--output",
    "json",
    "--status",
    args.status,
]
process = subprocess.run(cmd, capture_output=True, text=True)

if process.returncode != 0:
    print(f"Error running command: {process.stderr}")
    sys.exit(1)

data = json.loads(process.stdout)

if not data:
    print("No data found.")
    sys.exit(1)

# Define column headers
headers = ["ID", "Number", "Status", "Result", "Branch", "QueuedTime", "Message"]
rows = []

# Define the maximum length for the truncated message
MAX_MESSAGE_LENGTH = 100

for run in data:
    id = str(run.get("id", ""))
    number = run.get("buildNumber", "")
    status = run.get("status", "")
    result = run.get("result", "")
    branch = run.get("sourceBranch", "").replace("refs/heads/", "")
    queued_time = run.get("queueTime", "")
    message = run.get("triggerInfo", {}).get("ci.message", "")

    # Format the time
    if queued_time:
        try:
            dt = datetime.fromisoformat(queued_time)
            queued_time = dt.strftime("%Y-%m-%d %H:%M:%S")
        except ValueError:
            pass  # Keep the original if conversion fails

    # Truncate message if the flag for full message is not set
    if not args.full_message and len(message) > MAX_MESSAGE_LENGTH:
        message = message[:MAX_MESSAGE_LENGTH] + "..."

    rows.append([id, number, status, result, branch, queued_time, message])

# Calculate column widths
column_widths = [len(header) for header in headers]
for row in rows:
    for i, item in enumerate(row):
        column_widths[i] = max(column_widths[i], len(str(item)))


# Print the table
def print_row(items):
    print("  ".join(str(item).ljust(column_widths[i]) for i, item in enumerate(items)))


print_row(headers)
print_row(["-" * width for width in column_widths])
for row in rows:
    print_row(row)
